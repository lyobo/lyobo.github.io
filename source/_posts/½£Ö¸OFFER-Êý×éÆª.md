---
title: 剑指OFFER-数组篇
date: 2019-11-26 16:00:49
tags: 数组
categories: coding
comments: true
toc: true
---

## 顺序矩阵判断数字是否存在
### 思路1
暴力方法，直接进行顺序遍历

### 思路2
想到矩阵左下角为特殊位置，上面的值都比他小，右边的值都比他大
通过比较的数字和左下角数字的比较，进而进行追溯找到对应区间。

## 构建乘积数组
题目：给定一个数组A[0,1,...,n-1],请构建一个数组B[0,1,...,n-1],其中B中的元素B[i]=A[0]\*A[1]\*...\*A[i-1]\*A[i+1]\*...\*A[n-1]。不能使用除法。

思路：重点要考虑i左边和右边乘积的递归规律
假如左边乘积是C[i]
C[0] = 1
C[1] = C[0] \* A[0]
C[2] = C[1] \* A[1]
右侧乘积同理，如此递归可以减少计算代价，避免重复计算

重点在于找规律。


## 找重复数字
题目：在一个长度为n的数组里的所有数字都在0到n-1的范围内。 数组中某些数字是重复的，但不知道有几个数字是重复的。也不知道每个数字重复几次。请找出数组中任意一个重复的数字。 例如，如果输入长度为7的数组{2,3,1,0,2,5,3}，那么对应的输出是第一个重复的数字2。

### 思路一
暴力法，从头遍历，没有的存进temp，新data存在于temp就输入有重复的，否则继续

### 思路二

题目里写了数组里数字的范围保证在0 ~ n-1 之间，所以可以利用现有数组设置标志，当一个数字被访问过后，可以设置对应位上的数 + n，之后再遇到相同的数时，会发现对应位上的数已经大于等于n了，那么直接返回这个数即可。
```python
n = len(numbers)
for i in range(n):
    index = numbers[i]
    if index >= n:
        index -= n
    if numbers[index] >= n:
        return index
    numbers[index] = numbers[index] + n
return -1
```


