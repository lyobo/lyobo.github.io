{"pages":[{"title":"分类列表","text":"","link":"/categories/index.html"},{"title":"标签","text":"","link":"/tags/index.html"}],"posts":[{"title":"20191011120631","text":"","link":"/2019/10/11/20191011120631/"},{"title":"20191101140808","text":"","link":"/2019/11/01/20191101140808/"},{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2019/09/10/hello-world/"},{"title":"剑指OFFER-数组篇","text":"顺序矩阵判断数字是否存在思路1暴力方法，直接进行顺序遍历 思路2想到矩阵左下角为特殊位置，上面的值都比他小，右边的值都比他大通过比较的数字和左下角数字的比较，进而进行追溯找到对应区间。 构建乘积数组题目：给定一个数组A[0,1,…,n-1],请构建一个数组B[0,1,…,n-1],其中B中的元素B[i]=A[0]*A[1]*…*A[i-1]*A[i+1]*…*A[n-1]。不能使用除法。 思路：重点要考虑i左边和右边乘积的递归规律假如左边乘积是C[i]C[0] = 1C[1] = C[0] * A[0]C[2] = C[1] * A[1]右侧乘积同理，如此递归可以减少计算代价，避免重复计算 重点在于找规律。 找重复数字题目：在一个长度为n的数组里的所有数字都在0到n-1的范围内。 数组中某些数字是重复的，但不知道有几个数字是重复的。也不知道每个数字重复几次。请找出数组中任意一个重复的数字。 例如，如果输入长度为7的数组{2,3,1,0,2,5,3}，那么对应的输出是第一个重复的数字2。 思路一暴力法，从头遍历，没有的存进temp，新data存在于temp就输入有重复的，否则继续 思路二题目里写了数组里数字的范围保证在0 ~ n-1 之间，所以可以利用现有数组设置标志，当一个数字被访问过后，可以设置对应位上的数 + n，之后再遇到相同的数时，会发现对应位上的数已经大于等于n了，那么直接返回这个数即可。 123456789n = len(numbers)for i in range(n): index = numbers[i] if index &gt;= n: index -= n if numbers[index] &gt;= n: return index numbers[index] = numbers[index] + nreturn -1","link":"/2019/11/26/剑指OFFER-数组篇/"},{"title":"测试文件","text":"this is a picture test file tasdfajsdlkfj laksdjf klasdlf","link":"/2019/09/10/测试文件/"},{"title":"牛客刷题","text":"求二叉树的最大深度主要思想——递归 12345678910111213141516171819class Solution {public: int maxDepth(TreeNode *root) { if(!root) { return 0; } int l=0,r=0; if(root-&gt;right) { r = maxDepth(root-&gt;right); } if(root-&gt;left) { l = maxDepth(root-&gt;left); } return max(l,r) + 1; }}; 求二叉树的最小深度注意递归停止的条件，考虑左右节点均为空的情况。 1234567891011121314151617181920212223class Solution {public: int run(TreeNode *root) { if(!root) { return 0; } int l=0,r=0; if(root-&gt;right) { r = run(root-&gt;right); } if(root-&gt;left) { l = run(root-&gt;left); } if(l==0||r==0) { return 1+r+l; } return min(l,r) +1; }};","link":"/2019/09/17/牛客刷题/"}],"tags":[{"name":"数组","slug":"数组","link":"/tags/数组/"},{"name":"树","slug":"树","link":"/tags/树/"}],"categories":[{"name":"research","slug":"research","link":"/categories/research/"},{"name":"编程","slug":"编程","link":"/categories/编程/"},{"name":"coding","slug":"coding","link":"/categories/coding/"}]}